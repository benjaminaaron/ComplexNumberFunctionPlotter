<html> 
	<head> 
		<title>complex number function plotter</title> 

		<script type="text/javascript" src="js/jquery-2.1.1.min.js"></script>
		<script type="text/javascript" src="js/three.min.js"></script> 
		<script type="text/javascript" src="js/OrbitControls.js"></script>

		<style> 
		</style> 
	</head> 
	<body> 

		<div id="ThreeJS" style="z-index: 1; position: absolute; left:0px; top:0px"></div>
	
		<script>

			var container, scene, camera, renderer, controls;
			var geometry, sphereGeometry, material, lineMaterial, planeMaterial, sphereMaterial;

			var inputPlaneWidth = 10;
			var inputPlaneHeight = 10;
			var inputToResultPlaneDiff = 30;

			//var resultPlaneWidth = 20;
			//var resultPlaneHeight = 20;

			function init() {
				scene = new THREE.Scene();
				var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;	
				var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
				camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);	
				camera.position.set(50,40,50); camera.lookAt(scene.position); scene.add(camera);

				renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setClearColor(0xeeeeee); renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
				container = document.getElementById('ThreeJS'); container.appendChild(renderer.domElement);

				controls = new THREE.OrbitControls(camera, renderer.domElement);
				light = new THREE.DirectionalLight(0xffffff); light.position.set(1, 1, 1); scene.add(light);
				light = new THREE.DirectionalLight(0x002288); light.position.set(-1, -1, -1); scene.add(light);
				light = new THREE.AmbientLight(0x222222); scene.add(light);
				//var axes = new THREE.AxisHelper(20); scene.add(axes);

				// INPUT PLANE
				geometry = new THREE.PlaneBufferGeometry(inputPlaneWidth, inputPlaneHeight, 32);
				planeMaterial = new THREE.MeshBasicMaterial({color: 0xbbbbbb, side: THREE.DoubleSide, transparent: true, opacity: 0.5});
				var plane = new THREE.Mesh(geometry, planeMaterial);
				//plane.position.set(0, 0, 0);
       		 	scene.add(plane);


       		 	// DRAW LINES
				var steps = 1;
				var resultMinReal = Number.MAX_VALUE;
				var resultMaxReal = - Number.MAX_VALUE;
				var resultMinImg = Number.MAX_VALUE;
				var resultMaxImg = - Number.MAX_VALUE;

				//material = new THREE.LineBasicMaterial({color: 'rgb(0, 255, 0)', linewidth: 4});

				var Line = function(inputC, resultC, threeLineGeometry){
					this.inputC = inputC;
					this.resultC = resultC;
					this.threeLineGeometry = threeLineGeometry;
				}
				var lines = [];

				var minFact = Number.MAX_VALUE;
				var maxFact = - Number.MAX_VALUE;

				//do the calculations
				for(var r = - inputPlaneWidth / 2; r <= inputPlaneWidth / 2; r = r + steps){
					for(var i = - inputPlaneHeight / 2; i <= inputPlaneHeight / 2; i = i + steps){
						var inputC = new C(r, i);
						var resultC = pow(inputC, 2); //FUNCTION
						var resR = resultC.r;
						var resI = resultC.i;
						var fact = inputC.length / resultC.length;
						
						console.log(inputC + ' -> ' + resultC + ' fact: ' + roundVal(inputC.length, 1) + '/' + roundVal(resultC.length, 1) + '=' + roundVal(fact, 2));
						
						if(fact < minFact)
							minFact = fact;
						if(fact > maxFact)
							maxFact = fact;
					
						if(resR < resultMinReal)
							resultMinReal = resR;
						if(resI < resultMinImg)
							resultMinImg = resI;
						if(resR > resultMaxReal)
							resultMaxReal = resR;
						if(resI > resultMaxImg)
							resultMaxImg = resI;

						geometry = new THREE.Geometry();
						geometry.vertices.push(
							new THREE.Vector3(inputC.r, inputC.i, 0),
							new THREE.Vector3(resultC.r, resultC.i, inputToResultPlaneDiff)
						);
						var line = new Line(inputC, resultC, geometry);
						lines.push(line)
					}
				}
				//console.log(minFact); console.log(maxFact);

				

				//calculate colors and add lines and circles to the scene
				for(var i=0; i < lines.length; i++){
					var inputC = lines[i].inputC;

					var resultC = lines[i].resultC;
					var fact = inputC.length / resultC.length;
					if(isNaN(fact))
						fact = 0;
					else 
						fact = Math.pow(fact, 0.5);

					sphereGeometry = new THREE.SphereGeometry(0.1 + 0.2 * fact, 16, 16); 

					fact = Math.round((1 - fact) * 255);
					var colStr = 'rgb(' + 0 + ',' + 0 + ',' + fact + ')';
					lineMaterial = new THREE.LineBasicMaterial({color: colStr, linewidth: 1});
					sphereMaterial = new THREE.MeshLambertMaterial({color: colStr}); 

					var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
					sphere.position.set(inputC.r, inputC.i, 0);
					scene.add(sphere);

					var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
					sphere.position.set(resultC.r, resultC.i, inputToResultPlaneDiff);
					scene.add(sphere);

					scene.add(new THREE.Line(lines[i].threeLineGeometry, lineMaterial));
				}

				// RESULT PLANE
				var resultPlaneWidth = resultMinReal * -1 + Math.abs(resultMaxReal);
				var resultPlaneHeight = resultMinImg * -1 + Math.abs(resultMaxImg);
       			geometry = new THREE.PlaneBufferGeometry(resultPlaneWidth, resultPlaneHeight, 32);
				plane = new THREE.Mesh(geometry, planeMaterial);
				var middleDiffReal = resultMinReal + resultPlaneWidth / 2;
				var middleDiffImg = resultMinImg + resultPlaneHeight / 2;
				//console.log(resultMinReal); console.log(resultMaxReal); console.log(resultMinImg); console.log(resultMaxImg);
				//console.log(resultPlaneWidth); console.log(resultPlaneHeight); console.log(middleDiffReal); console.log(middleDiffImg);
				plane.position.set(middleDiffReal, middleDiffImg, inputToResultPlaneDiff);
       		 	scene.add(plane);
			}


			function animate() {
			    requestAnimationFrame(animate);
				renderer.render(scene, camera);	
			}


			function randomColor(){
				return '#' + Math.floor(Math.random() * 16777215).toString(16);
			}

			function showPoint(x, y, z){	
				var col = randomColor();
				var sphereGeometry = new THREE.SphereGeometry(0.6); 
				var sphereMaterial = new THREE.MeshLambertMaterial({color: col});
				var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
				sphere.position.set(x, y, z);
				scene.add(sphere);
			}

			function dist(x1, y1, z1, x2, y2, z2){
				return Math.sqrt(Math.pow(x2-x1,2) + Math.pow(y2-y1,2) + Math.pow(z2-z1,2));
			}

			function roundVal(val, decPlaces){
				if(('' + val).split('.').length > 1){ //if has decimal places TODO check better?
					var fact = Math.pow(10,decPlaces);
					return Math.round(val * fact) / fact;
				} else {
					return val;
				}	
			}

			var C = function(r, i){
				this.r = r;
				this.i = i;
				this.length = Math.sqrt(Math.pow(r,2) + Math.pow(i,2));
				this.angle = Math.atan(i / r);
				this.toString = function(){
					return '(' + roundVal(this.r,2) + ' ' + (this.i < 0 ? '-' : '+') + ' ' + (Math.abs(this.i) == 1 ? 'i' : roundVal(Math.abs(this.i),2) + 'i') + ')'; 
				}
			}  

			var add = function(C1, C2){
				return new C(C1.r + C2.r, C1.i + C2.i);
			}

			var sub = function (C1, C2){
				return new C(C1.r - C2.r, C1.i - C2.i);
			}

			var mul = function(C1, C2){//(a + bi) (g + hi) = ag + ahi + big - bh
				var newR = C1.r * C2.r - C1.i * C2.i; 
				var newI = C1.r * C2.i + C1.i * C2.r;
				return new C(newR, newI);
			}

			var div = function(C1, C2){
				var divisor = Math.pow(C2.r,2) + Math.pow(C2.i,2);
				var newR = (C1.r * C2.r + C1.i * C2.i) / divisor;
				var newI = (C1.i * C1.r - C1.r * C2.i) / divisor;
				return new C(newR, newI);
			}

			var pow = function(Cbase, exp){
				if(exp == 0)
					return new C(1, 0);
				var temp = new C(Cbase.r, Cbase.i);
				for(var i = 1; i < exp; i++){
					temp = mul(temp, Cbase);
				}
				return temp;
			}

			//TODO sqrt

			/*$(document).ready(function() {
				var c1 = new C(1, 2);
				var c2 = new C(2, 3)
				console.log(c1 + ' * ' + c2 + ' = ' + mul(c1,c2));
				console.log(c1 + ' + ' + c2 + ' = ' + add(c1,c2));
				console.log(c1 + ' - ' + c2 + ' = ' + sub(c1,c2));
				console.log(c1 + ' / ' + c2 + ' = ' + div(c1,c2));
				console.log(c1 + '^3 = ' + pow(c1,3));
			});*/

			init();
			animate();

			/* PARKING LOT 
			
			...

			*/
	
		</script>
	</body> 
</html>





